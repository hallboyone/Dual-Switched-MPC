\section{Algorithm Design}
Before addressing the circular dependency mentioned in the previous section, an algorithm to find the safe-sets of a single agent is developed. To avoid the circular dependency, it is assumed that the other agents have fixed safe-sets. Then the disturbance caused by the neighboring agents can be bound with
\begin{equation}
\wcon[\agentidx][\modeidx]=\prod_{\tilde{\agentidx}\in\idxset{\numagents}}\Call{ConHull}{\cup\mathcal{S}^{\tilde{\agentidx}}}.
\end{equation}
With these sets, \autoref{alg:node_safe_sets} is introduced to compute the maximal safe-set collections for this mode. 
\begin{algorithm}[t]
\caption{Nodal safe-sets with previewed disturbances}\label{alg:node_safe_sets}
\begin{algorithmic}[1]
\Procedure {AgentSafeSets}{$\agent{\agentidx}$}
\State $k\gets0$
\State $\Omega_{n}^k\gets\xcon[\gnodelabel{n}]$ for all $n\in\idxset{\gnumnodes[\agentidx]}$.
\Repeat 
	\State $k\gets k+1$
	\For{$n\in\idxset{\gnumnodes[\agentidx]}$}
		\State $\Omega_{n}^k\gets\Omega_{n}^{k-1}$
		\For{$\tilde{n}\in\gnodeedges[\agentidx]{n}$}
				\State $\Omega_{n}^k\gets\Omega_{n}^k\cap\PreviewedPre[\gnodelabel{\tilde{n}}][1]{\Omega_{\tilde{n}}^{k-1}}$
			\EndFor
	\EndFor
\Until{$\Omega_{n}^k=\Omega_{n}^{k-1}\ \forall\ n\in\idxset{\gnumnodes[\agentidx]}$.}
\State $\safeset{}^\agentidx\gets\{\Omega_{n}^k\}_{n\in\idxset{\gnumnodes[\agentidx]}}$.\;
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{remark}
An important distinction between this algorithm and previous algorithms focused on robust control is the use of the previewed robust preset operator. This operator is used in place of the more common robust preset operator to increase the size of the resulting safe-sets. Its use only assumes that each block-row is aware to the states of other block-rows prior to selecting a control action. This is a minor assumption that requires little communication overhead.
\end{remark}
\autoref{alg:node_safe_sets} is supported with the following lemmas. 
\begin{lemma}\label{lemma:maximal_proof}
Given any agent, $\agent{\agentidx}$, $\Call{AgentSafeSets}{\agent{\agentidx}}$ returns the maximal safe-set collection.
\end{lemma}
\begin{proof}
Follows the logic of \cite[Theorem 2]{Danielson2019} but with previewed preset operations.
\end{proof}
\begin{lemma}
Given two agents, $\agent{\tilde\agentidx}$ and $\agent{\hat\agentidx}$, that are equivalent except for their disturbance bounds which satisfy $E_{\modeidx}^{\tilde\agentidx}\circ\wconset{\tilde\agentidx}_\modeidx\subseteq E_{\modeidx}^{\hat\agentidx}\circ\wconset{\hat\agentidx}_\modeidx$ for each mode, the relationship
$$\Call{AgentSafeSets}{\agent{\tilde\agentidx}}\supseteq\Call{AgentSafeSets}{\agent{\hat\agentidx}}$$
also holds element-wise. 
\end{lemma}
\begin{proof}
This is proved by contradiction. Let some index, $n\in\idxset{\gnumnodes[\tilde\agentidx]}$, exist such that $\mathcal{S}_n^{\tilde\agentidx}\subset\mathcal{S}_n^{\hat\agentidx}$. Since \autoref{alg:node_safe_sets} is subtractive, this implies that $\exists k\in\int\rgeq{0}$ such that $\tilde\Omega^k_{n}\subset\hat\Omega^k_{n}$. By definition, there exists an $x\in\hat\Omega^k_{n}$ such that $x\not\in\tilde\Omega^k_{n}$. This requires that at least one of the following statements be true:
\begin{enumerate}
\item $x\in\hat\Omega^{k-1}_{n}$ and $x\not\in\tilde\Omega^{k-1}_{n}$ or
\item There exists an index, $m\in\idxset{\gnumnodes[\tilde\agentidx]}$, s.t. $x\in\PreviewedPre[\gnodelabel{m}][1]{\hat\Omega^{k-1}_{m}}$ and $x\not\in\PreviewedPre[\gnodelabel{m}][1]{\tilde\Omega^{k-1}_{m}}$.
\end{enumerate}
If (1) is true, then $\tilde\Omega^{k-1}_{n}\subset\hat\Omega^{k-1}_{n}$. If (2) is true, then $\tilde\Omega^{k-1}_{m}\subset\hat\Omega^{k-1}_{m}$ since $E_{\gnodelabel{m}}^{\tilde\agentidx}\circ\wconset{\tilde\agentidx}_{\gnodelabel{m}}\subseteq E_{\gnodelabel{m}}^{\hat\agentidx}\circ\wconset{\hat\agentidx}_{\gnodelabel{m}}$ by assumption. In either case, the above logic can be repeated with $k=k-1$ and, if (2) is true, $n=m$. This can continue until $k=0$ and the contradiction $\xcon = \tilde\Omega^0_{n}\subset\hat{\Omega}^0_{n}=\xcon$ is arrived at, concluding the proof. 
\end{proof}

\autoref{alg:node_safe_sets} is an important tool but requires that the safe-sets of the other block-rows are already known. As mentioned in the previous section, there is a circular dependency where the neighboring safe-sets depend on the local safe-sets which, using \autoref{alg:node_safe_sets}, depends on the neighboring safe-sets. This circular dependency is addressed in \autoref{alg:safe_sets}. Starting from an initial, trivial guess for feasible, safe-set collections, the algorithm first generates safe-sets that are too large and infeasible and then safe-sets that are small but feasible. This process is repeated until a convergence criteria is met. Critically, the algorithm can be parallelized along the different block-rows. As block-rows are added, the computational complexity grows at a near linear rate as opposed to the exponential rate of the centralized case. Furthermore, as shown in the following lemma the algorithm produces a feasible collection of safe-sets after each complete iteration. This allows the user to terminate after any complete iteration and produce valid results. 
\begin{algorithm}[t]
\caption{Distributed safe-set collection for system in \autoref{eq:agent_notation}}\label{alg:safe_sets}
\begin{algorithmic}[1]
\Procedure {SystemSafeSets}{$\agents$}
\State $\Omega^0\gets\{\{\underline{0}\}_{n\in\idxset{\gnumnodes[\agentidx]}}\}_{\agentidx\in\mathcal{I}_\agentidx}$
\State $\Phi^0\gets\{\underline{0}\}_{\agentidx\in\mathcal{I}_\agentidx}$
\State $k\gets0$
\Repeat
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\wcon[\modeidx]^\agentidx\gets\prod_{\tilde{\agentidx}\in\idxset{\numagents}}\Phi^{k}_{(\tilde\agentidx)}$ for all $\modeidx\in\idxset{\nummodes[\agentidx]}$
	\EndParFor
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\Omega^{k+0.5}_{(\agentidx)}\gets\Call{AgentSafeSets}{\modes[\agentidx]}$
		\State $\Phi^{k+0.5}_{(\agentidx)}\gets\Call{ConHull}{\bigcup\Omega^{k+0.5}_{(\agentidx)}}$
	\EndParFor
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\wcon[\modeidx]^\agentidx\gets\prod_{\tilde{\agentidx}\in\idxset{\numagents}}\Phi^{k+0.5}_{(\tilde\agentidx)}$ for all $\modeidx\in\idxset{\nummodes[\agentidx]}$
	\EndParFor
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\Omega^{k+1}_{(\agentidx)}\gets\Call{AgentSafeSets}{\modes[\agentidx]}$
		\State $\Phi^{k+1}_{(\agentidx)}\gets\Call{ConHull}{\bigcup\Omega^{k+1}_{(\agentidx)}}$
	\EndParFor
	\State $k\gets k+1$
\Until{$\Omega_{(\agentidx)}^k=\Omega_{(\agentidx)}^{k-1}\ \forall\ \agentidx\in\mathcal{I}_\agentidx$}

\State $\safesets\gets\Omega^k$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{lemma}
The algorithm $\Call{SystemSafeSets}{\agents}$ produces a valid safe-set collection for every $k\in\int\rgeq{0}$. 
\end{lemma}
\begin{proof}
This holds trivially for $\Omega^0$. The following induction steps complete the proof.
\begin{enumerate}
	\item Assume $\Omega^k$ is valid under the disturbance constraints $\Phi^k$.
	\item By Lemma 1, $\Omega^k\subseteq\Omega^{k+0.5}$.
	\item By Lemma 2, $\Phi^k\subseteq\Phi^{k+0.5}$ implies that $\Omega^{k+1}\subseteq\Omega^{k+0.5}$.
	\item Since $\Omega^{k+1}$ is valid for $\Phi^{k+0.5}$, it will also be valid for $\Phi^{k+1}$ since $\Phi^{k+1}\subseteq\Phi^{k+0.5}$.
\end{enumerate}
\end{proof}