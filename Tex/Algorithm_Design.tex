\section{Algorithm Design}
Before addressing the circular dependency mentioned in the previous section, an algorithm to find the safe-sets of a single agent is developed. To avoid the circular dependency, it is assumed that the other agents have fixed safe-sets. Then the disturbance caused by the neighboring agents can be bound with
\begin{equation}
\wcon[\agentidx][\modeidx]=\prod_{\tilde{\agentidx}\in\idxset{\numagents}}\Call{ConHull}{\cup\mathcal{S}^{\tilde{\agentidx}}}.
\end{equation}
With these sets, \autoref{alg:node_safe_sets} is introduced to compute the maximal safe-set collections for this mode. 
\begin{algorithm}[t]
\caption{Nodal safe-sets with previewed disturbances}\label{alg:node_safe_sets}
\begin{algorithmic}[1]
\Procedure {AgentSafeSets}{$\agent{\agentidx}$}
\State $k\gets0$
\State $\Omega_{n}^k\gets\xcon[\gnodelabel{n}]$ for all $n\in\idxset{\gnumnodes[\agentidx]}$.
\Repeat 
	\State $k\gets k+1$
	\For{$n\in\idxset{\gnumnodes[\agentidx]}$}
		\State $\Omega_{n}^k\gets\Omega_{n}^{k-1}$
		\For{$\tilde{n}\in\gnodeedges[\agentidx]{n}$}
				\State $\Omega_{n}^k\gets\Omega_{n}^k\cap\PreviewedPre[\gnodelabel{\tilde{n}}][1]{\Omega_{\tilde{n}}^{k-1}}$
			\EndFor
	\EndFor
\Until{$\Omega_{n}^k=\Omega_{n}^{k-1}\ \forall\ n\in\idxset{\gnumnodes[\agentidx]}$.}
\State $\safeset{}^\agentidx\gets\{\Omega_{n}^k\}_{n\in\idxset{\gnumnodes[\agentidx]}}$.\;
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{remark}
An important distinction between this algorithm and previous algorithms focused on robust control is the use of the previewed robust preset operator. This operator is used in place of the more common robust preset operator to increase the size of the resulting safe-sets. Its use only assumes that each block-row is aware to the states of other block-rows prior to selecting a control action. This is a minor assumption that requires little communication overhead.
\end{remark}
\autoref{alg:node_safe_sets} is supported with the following lemmas. 
\begin{lemma}\label{lemma:maximal_proof}
Given any agent, $\agent{\agentidx}$, $\Call{AgentSafeSets}{\agent{\agentidx}}$ returns the maximal safe-set collection.
\end{lemma}
\begin{proof}
Follows the logic of \cite[Theorem 2]{Danielson2019} but with previewed preset operations.
\end{proof}
\begin{lemma}
Let $\agent{\tilde\agentidx}$ and $\agent{\hat\agentidx}$ be two switched systems that are equivalent except for their disturbance bounds which satisfy $E_{\modeidx}^{\agentidx}\circ\wconset{\tilde\agentidx}_\modeidx\subseteq E_{\modeidx}^{\agentidx}\circ\wconset{\hat\agentidx}_\modeidx$ for each mode where $E_{\modeidx}^{\agentidx}=E_{\modeidx}^{\tilde\agentidx}=E_{\modeidx}^{\hat\agentidx}$. Then the relationship
$$\Call{AgentSafeSets}{\agent{\tilde\agentidx}}\supseteq\Call{AgentSafeSets}{\agent{\hat\agentidx}}$$
also holds element-wise. 
\end{lemma}
\begin{proof}
This is proved by contradiction. Let $n\in\idxset{\gnumnodes[\tilde\agentidx]}$ be some node for which $\exists\ x\not\in\mathcal{S}_n^{\tilde{\agentidx}}\ \land\ x\in\mathcal{S}_n^{\hat{\agentidx}}$. Since \autoref{alg:node_safe_sets} is subtractive, there exists some minimal $k\in\int\rgeq{0}$ such that $\exists\ x\not\in\tilde\Omega^k_{n}\ \land\ x\in\hat\Omega^k_{n}$. This implies that there exists a node neighboring $n$, $m\in\gnodeedges[\agentidx]{n}$ with label $\ell_m$, such that there exists an $x$ that violates the preset condition found on line 9 of the algorithm for  $\agent{\tilde\agentidx}$ while respecting it for  $\agent{\hat\agentidx}$.  Using \autoref{def:prev_robust_preset}, this can be stated as $\exists\ x\ \st${\small
\begin{align*}
\exists w\in\wcon[{\ell_m}]^{\tilde{\agentidx}}\ \st\ \forall\ u\in\ucon[{\ell_m}]^\agentidx,\ A_{\ell_m}^\agentidx x+B_{\ell_m}^\agentidx u + E_{\ell_m}^\agentidx w \not\in \tilde\Omega^{k-1}_{{\ell_m}}
\end{align*}}
and{\small
\begin{align*}
\forall w\in\wcon[{\ell_m}]^{\hat{\agentidx}}\ \st\ \exists\ u\in\ucon[{\ell_m}]^\agentidx,\ A_{\ell_m}^\agentidx x+B_{\ell_m}^\agentidx u + E_{\ell_m}^\agentidx w \in \hat\Omega^{k-1}_{{\ell_m}}
\end{align*}}
where the decorations on the $\agentidx$ have been dropped on equivalent values between the two systems. By the relationship given in the lemma body, the second statement above would hold even if $\wcon[{\ell_m}]^{\hat{\agentidx}}$ were replaced with $\wcon[{\ell_m}]^{\tilde{\agentidx}}$. Let $z$ be the corresponding point for which $\exists w\in\wcon[{\ell_m}]^{\tilde{\agentidx}},\ u\in\ucon[{\ell_m}]^\agentidx$ such that $z\not\in\tilde\Omega^{k-1}_{m}\ \land\ z\in\hat\Omega^{k-1}_{m}$. This is equivalent to the starting condition only at a new state and node and with a decremented index. The above logic can be iterated until $k=0$ and the contradiction $\xcon[\ell_n] = \tilde\Omega^0_{n}\subset\hat{\Omega}^0_{n}=\xcon[\ell_n]$ is arrived at, concluding the proof. 
\end{proof}

\autoref{alg:node_safe_sets} is an important tool but requires that the safe-sets of the other block-rows are already known. As mentioned in the previous section, there is a circular dependency where the neighboring safe-sets depend on the local safe-sets which, using \autoref{alg:node_safe_sets}, depends on the neighboring safe-sets. This circular dependency is addressed in \autoref{alg:safe_sets}. Starting from an initial, trivial guess for feasible, safe-set collections, the algorithm first generates safe-sets that are too large and infeasible and then safe-sets that are small but feasible. This process is repeated until a convergence criteria is met. Critically, the algorithm can be parallelized along the different block-rows. As block-rows are added, the computational complexity grows at a near linear rate as opposed to the exponential rate of the centralized case. Furthermore, as shown in the following lemma the algorithm produces a feasible collection of safe-sets after each complete iteration. This allows the user to terminate after any complete iteration and produce valid results. 
\begin{algorithm}[t]
\caption{Distributed safe-set collection for system in \autoref{eq:agent_notation}}\label{alg:safe_sets}
\begin{algorithmic}[1]
\Procedure {SystemSafeSets}{$\agents$}
\State $\Omega^0\gets\{\{\underline{0}\}_{n\in\idxset{\gnumnodes[\agentidx]}}\}_{\agentidx\in\mathcal{I}_\agentidx}$
\State $\Phi^0\gets\{\underline{0}\}_{\agentidx\in\mathcal{I}_\agentidx}$
\State $k\gets0$
\Repeat
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\wcon[\modeidx]^\agentidx\gets\prod_{\tilde{\agentidx}\in\idxset{\numagents}}\Phi^{k}_{(\tilde\agentidx)}$ for all $\modeidx\in\idxset{\nummodes[\agentidx]}$
	\EndParFor
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\Omega^{k+0.5}_{(\agentidx)}\gets\Call{AgentSafeSets}{\modes[\agentidx]}$
		\State $\Phi^{k+0.5}_{(\agentidx)}\gets\Call{ConHull}{\bigcup\Omega^{k+0.5}_{(\agentidx)}}$
	\EndParFor
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\wcon[\modeidx]^\agentidx\gets\prod_{\tilde{\agentidx}\in\idxset{\numagents}}\Phi^{k+0.5}_{(\tilde\agentidx)}$ for all $\modeidx\in\idxset{\nummodes[\agentidx]}$
	\EndParFor
	\ParFor{$\agentidx\in\mathcal{I}_\agentidx$}
		\State $\Omega^{k+1}_{(\agentidx)}\gets\Call{AgentSafeSets}{\modes[\agentidx]}$
		\State $\Phi^{k+1}_{(\agentidx)}\gets\Call{ConHull}{\bigcup\Omega^{k+1}_{(\agentidx)}}$
	\EndParFor
	\State $k\gets k+1$
\Until{$\Omega_{(\agentidx)}^k=\Omega_{(\agentidx)}^{k-1}\ \forall\ \agentidx\in\mathcal{I}_\agentidx$}

\State $\safesets\gets\Omega^k$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{lemma}
The algorithm $\Call{SystemSafeSets}{\agents}$ produces a valid safe-set collection for every $k\in\int\rgeq{0}$. 
\end{lemma}
\begin{proof}
This holds trivially for $\Omega^0$. The following induction steps complete the proof.
\begin{enumerate}
	\item Assume $\Omega^k$ is valid under the disturbance constraints $\Phi^k$.
	\item By Lemma 1, $\Omega^k\subseteq\Omega^{k+0.5}$.
	\item By Lemma 2, $\Phi^k\subseteq\Phi^{k+0.5}$ implies that $\Omega^{k+1}\subseteq\Omega^{k+0.5}$.
	\item Since $\Omega^{k+1}$ is valid for $\Phi^{k+0.5}$, it will also be valid for $\Phi^{k+1}$ since $\Phi^{k+1}\subseteq\Phi^{k+0.5}$.
\end{enumerate}
\end{proof}