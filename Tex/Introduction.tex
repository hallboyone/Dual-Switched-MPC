\section{Introduction}
Hybrid systems are a broad and important class of systems with both discrete and continuous (or discrete approximations of continuous) dynamics. A subclass of these are systems whose discrete dynamics are purely time dependent and unknown to the system. For example, user input and component failures can both cause the system to suddenly change. Such discrete, external dynamics can be viewed as an external signal switching the system's dynamics at discrete, unforeseen times. If the system is constrained, then special care should be taken to make the system robust to these switches so that state and input constraints are not violated. 

If the system were allowed to be switched arbitrarily, then satisfying the constraints would require the controller to always keep the state within a control invariant set common to all modes \cite{Liberzon1999}. If the modes are not extremely similar, this may be a very difficult or impossible requirement meet. Instead of arbitrary switching, dwell time and successor constraints are often imposed on the switching signal \cite{Liberzon1999,Morse1999}. Minimum dwell time constraints give the system time to recover after a switch and prepare for the next one \cite{Danielson2019}, while maximum dwell time constraints ensure that the system will not dwell in ``poorly'' behaved modes for too long \cite{Hall2022}. These constraints can either be generated by the physical implementation and the controller designed to accommodate them (as in \cite{Danielson2019}), or they can be specified by the controller and enforced in the physical implementation (as in \cite{Zhang2016}). Dwell time and successor constraints have been used in previous works to create time-varying control invariant sets that are robust to all possible switching signals \cite{Danielson2019}. Unfortunately, these methods can be very computationally expensive and suffer greatly from the curse of dimensionality, precluding their use in large-scale systems and motivating the techniques developed here.

A further shortcoming of the current literature is that only a single switching signal is explicitly considered. A naive solution to this would simply be to define a new switching signal with states corresponding to all the realizable permutations of the independent signals. While this would work in theory, it creates an exponential growth in the number of possible signal states. Seeking to enumerate these with even just two switching signals and define the dwell time and successor constraints of each mode quickly leads back to arbitrary switching and its associated challenges. Even if some weaker constraints could be maintained, the increase in the computational load with be difficult to overcome.

This work develops an algorithm that both reduces the computational expense of previous algorithms and accounts for systems with multiple sources of switching. The algorithm's most computationally expensive steps are parallelizable, greatly improving its scalability. Variations of this objective have been addressed in several previous works. Systems with a similar structure where studied in works such as \cite{Riverso2015} where the authors examine both the constrained and unconstrained cases. This was done, however, without any external switching but with a focus on plug-and-play design objectives. The authors of \cite{Ahandani2020} examine decentralized systems under MPC with shifting communication topologies providing a type of external switching. However, the local dynamics remained the same. The authors of \cite{Li2020} also looked at distributed MPC with switching communication topologies. The agents collaborated by sharing a preview of their future state trajectory. Using this information, inputs closer to the global optimal could be found the ensured stability. This work, however does not consider state constraints beyond terminal constraints and only considers switching in the communication network, not the local dynamics. 

The study of feasibility in externally switched systems has been addressed in a mostly separate field of study. The general method of ensuring persistent feasibility has relied on the construction of time-varying control invariant sets. \cite{Santis2004, Zhang2016, Danielson2019}. To address the problem of computational intractability, some previous works, such as \cite{Santis2004}, have used approximate set-based methods to reduce the computational complexity or terminate the algorithms early. None have, however, utilized the structure of the system to reduce the computational load of ensuring persistent feasibility. 

In the next section, notation and concepts are introduced that will be used throughout the reminder of the paper. Next, the general form of the system is described and the associated challenges are discussed further. Finally, several algorithms are introduced as key contributions of this work and their theoretical properties and implementation are explored. These are then applied to a numerical example that demonstrates their effectiveness. 